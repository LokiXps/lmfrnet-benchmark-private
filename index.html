<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="robots" content="noindex, nofollow">
    <title>ローカル環境で画像認識精度実験</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ライトモード設定 */
        :root {
            --bg: #f5f5f7;
            --surface: #ffffff;
            --surface-highlight: #f0f0f5;
            --border: #d1d1d6;
            --primary: #007aff;
            --success: #34c759;
            --danger: #ff3b30;
            --text-main: #1c1c1e;
            --text-sub: #8e8e93;
            --font-mono: 'SF Mono', 'Menlo', monospace;
        }

        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic ProN", "Segoe UI", Roboto, sans-serif;
            -webkit-font-smoothing: antialiased;
            padding-bottom: 40px;
            font-size: 14px;
        }

        .app-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 16px;
        }

        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin-bottom: 16px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            background: #fafafa;
            font-weight: 700;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-main);
        }

        /* Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1px;
            background: var(--border);
        }

        .metric-box {
            background: var(--surface);
            padding: 12px;
            text-align: center;
        }

        .metric-val {
            font-size: 20px;
            font-weight: 800;
            font-family: var(--font-mono);
            color: var(--primary);
        }

        .metric-label {
            font-size: 11px;
            color: var(--text-sub);
            margin-top: 4px;
            font-weight: 600;
        }

        /* Improved Table */
        .log-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            table-layout: fixed;
        }

        .log-table th {
            text-align: left;
            color: var(--text-sub);
            font-weight: 600;
            padding: 10px;
            border-bottom: 1px solid var(--border);
            background: #f9f9f9;
            font-size: 11px;
        }

        .log-table td {
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            vertical-align: middle;
            color: var(--text-main);
        }

        .col-img {
            width: 70px;
        }

        .col-res {
            width: 40px;
            text-align: center;
        }

        .col-conf {
            width: 60px;
            text-align: right;
            font-family: var(--font-mono);
            font-size: 11px;
            color: #888;
        }

        .status-icon {
            font-size: 16px;
        }

        .status-ok {
            color: var(--success);
        }

        .status-ng {
            color: var(--danger);
        }

        .thumb {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 6px;
            background: #eee;
            border: 1px solid #eee;
            cursor: zoom-in;
            transition: transform 0.1s;
        }

        .thumb:active {
            transform: scale(0.95);
        }

        /* Progress Bar */
        .progress-container {
            height: 6px;
            background: #e5e5ea;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 12px;
            display: none;
            /* Initially hidden */
        }

        .progress-bar {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.2s ease-out;
        }

        /* Controls */
        select,
        input[type="text"] {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 8px;
            border-radius: 8px;
            width: 100%;
            font-size: 14px;
        }

        button {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--primary);
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        button:active {
            transform: scale(0.98);
            background: #f0f0f0;
        }

        button.primary {
            background: var(--primary);
            color: white;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 122, 255, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            filter: grayscale(100%);
        }

        /* Custom Input List */
        .custom-item {
            display: flex;
            gap: 10px;
            padding: 10px;
            align-items: center;
            border-bottom: 1px solid #eee;
        }

        .custom-item:last-child {
            border-bottom: none;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            background: #e5e5ea;
            padding: 4px;
            border-radius: 10px;
        }

        .tab {
            flex: 1;
            padding: 8px;
            text-align: center;
            border-radius: 7px;
            color: #666;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .tab.active {
            background: white;
            color: black;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Dataset Grid */
        .dataset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            padding: 8px;
        }

        .dataset-item {
            position: relative;
            aspect-ratio: 1;
            overflow: hidden;
            border-radius: 6px;
            border: 1px solid #eee;
        }

        .dataset-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .dataset-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.9);
            font-size: 9px;
            padding: 2px 4px;
            text-align: center;
            border-top: 1px solid #eee;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
            overflow: hidden;
        }

        .modal-content img {
            max-width: 100%;
            max-height: 80vh;
            display: block;
        }

        .model-badge {
            font-size: 11px;
            background: #e0f2fe;
            color: #0369a1;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: normal;
            margin-left: 8px;
            font-family: var(--font-mono);
        }

        /* Result Text Styles */
        .res-label {
            display: block;
            font-weight: 700;
            line-height: 1.2;
        }

        .res-sub {
            display: block;
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }

        .res-correct {
            color: var(--success);
        }

        .res-error {
            color: var(--danger);
        }
    </style>
</head>

<body>

    <div class="app-container">
        <header class="flex justify-between items-center mb-4">
            <div>
                <h1 class="text-lg font-bold text-gray-900">ローカル環境で画像認識精度実験</h1>
                <p class="text-xs text-gray-500">オンデバイス推論 / オフライン対応</p>
            </div>
            <div id="model-status" class="text-xs px-2 py-1 rounded bg-gray-200 text-gray-500 font-bold">未ロード</div>
        </header>

        <!-- Load Section -->
        <div class="panel p-4 flex gap-2 items-end bg-white">
            <div class="flex-1">
                <label class="text-xs text-gray-500 block mb-1 font-bold">モデル選択</label>
                <select id="model-path"
                    class="w-full bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2.5">
                    <option value="./models_caltech101/lmfrnet.onnx" selected>LMFRNet (Default)</option>
                    <option value="./models_caltech101/lmfrnet_hires.onnx">LMFRNet Hires</option>
                    <option value="./models_caltech101/mobilenetv3_large.onnx">MobileNetV3 Large</option>
                    <option value="./models_caltech101/resnet18.onnx">ResNet18</option>
                </select>
            </div>
            <button onclick="loadModel()" id="load-btn" class="whitespace-nowrap h-[42px]">モデル読み込み</button>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <div class="tab active" onclick="switchTab('bench')">1. 精度実験 (200枚)</div>
            <div class="tab" onclick="switchTab('dataset')">2. データセット確認</div>
            <div class="tab" onclick="switchTab('custom')">3. カスタム検証</div>
        </div>

        <!-- TAB 1: Benchmark -->
        <div id="view-bench">
            <div class="panel">
                <div class="panel-header">
                    <span>実験結果</span>
                    <span class="model-badge model-name-display">Model: ---</span>
                </div>
                <div class="metrics-grid">
                    <div class="metric-box">
                        <div class="metric-val" id="bench-acc">--</div>
                        <div class="metric-label">正解率 (Accuracy)</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-val" id="bench-time">--ms</div>
                        <div class="metric-label">平均推論時間</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-val" id="bench-prog">0/200</div>
                        <div class="metric-label">完了数</div>
                    </div>
                </div>
                <div class="p-4 border-t border-[var(--border)]">
                    <button class="primary w-full py-3" id="btn-run-bench" onclick="runBenchmark()"
                        disabled>200枚ベンチマーク実行</button>

                    <!-- Progress Bar -->
                    <div id="bench-progress-container" class="progress-container">
                        <div id="bench-progress-bar" class="progress-bar"></div>
                    </div>

                    <p class="text-xs text-gray-400 mt-2 text-center">※ ./samples/ 以下の画像を順次読み込みます</p>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">
                    <span>実験結果(詳細)</span>
                    <span class="text-xs font-normal text-gray-500">画像クリックで拡大</span>
                </div>
                <div class="max-h-[400px] overflow-y-auto bg-white">
                    <table class="log-table">
                        <thead>
                            <tr>
                                <th class="col-res">判定</th>
                                <th class="col-img">画像(正解)</th>
                                <th>正解ラベル vs 予測結果</th>
                                <th class="col-conf">確信度</th>
                            </tr>
                        </thead>
                        <tbody id="bench-table-body">
                            <!-- JS inject -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- TAB 2: Dataset Preview -->
        <div id="view-dataset" class="hidden">
            <div class="panel">
                <div class="panel-header">
                    <span>Caltech101 テスト用データセット (200枚)</span>
                </div>
                <div class="p-2 bg-gray-50">
                    <p class="text-xs text-gray-500 mb-2 px-1">ベンチマークに使用される全画像リストです。画像をクリックするとパスを確認できます。</p>
                    <div id="dataset-grid" class="dataset-grid">
                        <div class="p-4 text-center text-gray-400 col-span-full">読み込み中...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB 3: Custom -->
        <div id="view-custom" class="hidden">
            <div class="panel p-4">
                <div class="mb-4">
                    <label class="block text-xs text-gray-500 font-bold mb-2">検証したい画像を追加 (複数選択可)</label>
                    <input type="file" id="custom-files" accept="image/*" multiple class="
                  block w-full text-sm text-slate-500
                  file:mr-4 file:py-2 file:px-4
                  file:rounded-full file:border-0
                  file:text-sm file:font-semibold
                  file:bg-blue-50 file:text-blue-700
                  hover:file:bg-blue-100
                  cursor-pointer
                " onchange="handleCustomFiles(this)">
                </div>

                <div id="custom-staging"
                    class="space-y-2 mb-4 bg-gray-50 rounded-lg border border-dashed border-gray-300 min-h-[100px] flex flex-col justify-center">
                    <p class="text-xs text-gray-400 text-center">ここにプレビューが表示されます</p>
                </div>

                <div class="flex gap-2">
                    <button class="flex-1 bg-white text-gray-600" onclick="clearCustom()">クリア</button>
                    <button class="primary flex-1" id="btn-run-custom" onclick="runCustomBatch()" disabled>検証開始</button>
                </div>
            </div>

            <div class="panel" id="custom-result-panel" style="display:none;">
                <div class="panel-header">
                    <span>検証結果</span>
                    <span class="model-badge model-name-display">Model: ---</span>
                </div>
                <div class="metrics-grid">
                    <div class="metric-box">
                        <div class="metric-val" id="custom-acc">--</div>
                        <div class="metric-label">正解率</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-val" id="custom-count">0</div>
                        <div class="metric-label">枚数</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-val" id="custom-time">--ms</div>
                        <div class="metric-label">平均時間</div>
                    </div>
                </div>
                <div class="max-h-[400px] overflow-y-auto bg-white">
                    <table class="log-table">
                        <thead>
                            <tr>
                                <th class="col-res">判定</th>
                                <th class="col-img">画像</th>
                                <th>指定ラベル vs 予測</th>
                                <th class="col-conf">確信度</th>
                            </tr>
                        </thead>
                        <tbody id="custom-table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Modal -->
    <div id="image-modal" class="modal-overlay" onclick="closeModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <img id="modal-img" src="">
            <div class="p-2 bg-white text-center">
                <button class="text-sm text-blue-500 font-bold" onclick="closeModal()">閉じる</button>
            </div>
        </div>
    </div>

    <script>
        const DEFAULT_MODEL_PATH = "./models_caltech101/lmfrnet.onnx";
        // ラベル定義 (Caltech-101)
        const LABELS = [
            { en: "Faces", ja: "顔" },
            { en: "Faces_easy", ja: "顔(Easy)" },
            { en: "Leopards", ja: "ヒョウ" },
            { en: "Motorbikes", ja: "バイク" },
            { en: "accordion", ja: "アコーディオン" },
            { en: "airplanes", ja: "飛行機" },
            { en: "anchor", ja: "錨" },
            { en: "ant", ja: "アリ" },
            { en: "barrel", ja: "樽" },
            { en: "bass", ja: "バス(魚)" },
            { en: "beaver", ja: "ビーバー" },
            { en: "binocular", ja: "双眼鏡" },
            { en: "bonsai", ja: "盆栽" },
            { en: "brain", ja: "脳" },
            { en: "brontosaurus", ja: "ブロントサウルス" },
            { en: "buddha", ja: "仏像" },
            { en: "butterfly", ja: "蝶" },
            { en: "camera", ja: "カメラ" },
            { en: "cannon", ja: "大砲" },
            { en: "car_side", ja: "車(横)" },
            { en: "ceiling_fan", ja: "シーリングファン" },
            { en: "cellphone", ja: "携帯電話" },
            { en: "chair", ja: "椅子" },
            { en: "chandelier", ja: "シャンデリア" },
            { en: "cougar_body", ja: "クーガー(体)" },
            { en: "cougar_face", ja: "クーガー(顔)" },
            { en: "crab", ja: "カニ" },
            { en: "crayfish", ja: "ザリガニ" },
            { en: "crocodile", ja: "ワニ" },
            { en: "crocodile_head", ja: "ワニ(頭)" },
            { en: "cup", ja: "カップ" },
            { en: "dalmatian", ja: "ダルメシアン" },
            { en: "dollar_bill", ja: "ドル札" },
            { en: "dolphin", ja: "イルカ" },
            { en: "dragonfly", ja: "トンボ" },
            { en: "electric_guitar", ja: "エレキギター" },
            { en: "elephant", ja: "象" },
            { en: "emu", ja: "エミュー" },
            { en: "euphonium", ja: "ユーフォニアム" },
            { en: "ewer", ja: "水差し" },
            { en: "ferry", ja: "フェリー" },
            { en: "flamingo", ja: "フラミンゴ" },
            { en: "flamingo_head", ja: "フラミンゴ(頭)" },
            { en: "garfield", ja: "ガーフィールド" },
            { en: "gerenuk", ja: "ゲレヌク" },
            { en: "gramophone", ja: "蓄音機" },
            { en: "grand_piano", ja: "グランドピアノ" },
            { en: "hawksbill", ja: "タイマイ(亀)" },
            { en: "headphone", ja: "ヘッドフォン" },
            { en: "hedgehog", ja: "ハリネズミ" },
            { en: "helicopter", ja: "ヘリコプター" },
            { en: "ibis", ja: "トキ" },
            { en: "inline_skate", ja: "インラインスケート" },
            { en: "joshua_tree", ja: "ジョシュアツリー" },
            { en: "kangaroo", ja: "カンガルー" },
            { en: "ketch", ja: "ケッチ(帆船)" },
            { en: "lamp", ja: "ランプ" },
            { en: "laptop", ja: "ノートPC" },
            { en: "llama", ja: "ラマ" },
            { en: "lobster", ja: "ロブスター" },
            { en: "lotus", ja: "蓮" },
            { en: "mandolin", ja: "マンドリン" },
            { en: "mayfly", ja: "カゲロウ" },
            { en: "menorah", ja: "メノラー" },
            { en: "metronome", ja: "メトロノーム" },
            { en: "minaret", ja: "ミナレット" },
            { en: "nautilus", ja: "オウムガイ" },
            { en: "octopus", ja: "タコ" },
            { en: "okapi", ja: "オカピ" },
            { en: "pagoda", ja: "塔" },
            { en: "panda", ja: "パンダ" },
            { en: "pigeon", ja: "鳩" },
            { en: "pizza", ja: "ピザ" },
            { en: "platypus", ja: "カモノハシ" },
            { en: "pyramid", ja: "ピラミッド" },
            { en: "revolver", ja: "リボルバー" },
            { en: "rhino", ja: "サイ" },
            { en: "rooster", ja: "雄鶏" },
            { en: "saxophone", ja: "サックス" },
            { en: "schooner", ja: "スクーナー(船)" },
            { en: "scissors", ja: "ハサミ" },
            { en: "scorpion", ja: "サソリ" },
            { en: "sea_horse", ja: "タツノオトシゴ" },
            { en: "snoopy", ja: "スヌーピー" },
            { en: "soccer_ball", ja: "サッカーボール" },
            { en: "stapler", ja: "ホッチキス" },
            { en: "starfish", ja: "ヒトデ" },
            { en: "stegosaurus", ja: "ステゴサウルス" },
            { en: "stop_sign", ja: "一時停止標識" },
            { en: "strawberry", ja: "イチゴ" },
            { en: "sunflower", ja: "ヒマワリ" },
            { en: "tick", ja: "ダニ" },
            { en: "trilobite", ja: "三葉虫" },
            { en: "umbrella", ja: "傘" },
            { en: "watch", ja: "腕時計" },
            { en: "water_lilly", ja: "スイレン" },
            { en: "wheelchair", ja: "車椅子" },
            { en: "wild_cat", ja: "ヤマネコ" },
            { en: "windsor_chair", ja: "ウィンザーチェア" },
            { en: "wrench", ja: "レンチ" },
            { en: "yin_yang", ja: "陰陽" }
        ];

        let BENCHMARK_DATA = [];
        let customImages = [];
        let worker = null;
        let workerReady = false;
        let modelLoadedOnWorker = false;
        let session = null;
        let currentModelName = "";
        let isRunning = false;
        let useMockInference = false;

        const statusEl = document.getElementById('model-status');
        const modelPathInput = document.getElementById('model-path');
        const benchTableBody = document.getElementById('bench-table-body');
        const benchAccEl = document.getElementById('bench-acc');
        const benchTimeEl = document.getElementById('bench-time');
        const benchProgEl = document.getElementById('bench-prog');
        const benchProgressBar = document.getElementById('bench-progress-bar');
        const benchProgressContainer = document.getElementById('bench-progress-container');
        const datasetGrid = document.getElementById('dataset-grid');
        const btnRunBench = document.getElementById('btn-run-bench');
        const btnRunCustom = document.getElementById('btn-run-custom');
        const customResultPanel = document.getElementById('custom-result-panel');

        // --- Initialization ---
        window.onload = async () => {
            // Mobile Safari/Chrome optimization
            ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/';
            ort.env.wasm.numThreads = 1;
            ort.env.wasm.simd = true;

            initWorker();
            await loadSamples();
            renderDatasetGrid();

            // Auto load default model
            await loadModel(true);
        };

        function initWorker() {
            try {
                worker = new Worker('worker.js');
                workerReady = true;
            } catch (e) {
                console.warn('Worker Init Failed:', e);
                workerReady = false;
            }
        }

        async function loadSamples() {
            try {
                const response = await fetch('samples.json');
                const samples = await response.json();
                BENCHMARK_DATA = samples.map((s, i) => ({
                    id: i,
                    path: `samples/${s.filename}`,
                    groundTruth: s.label
                }));
            } catch (e) {
                console.warn("samples.json not found, using mock data", e);
                BENCHMARK_DATA = Array.from({ length: 200 }, (_, i) => {
                    const labelIdx = Math.floor(Math.random() * LABELS.length);
                    return {
                        id: i,
                        path: `./samples/img_${String(i).padStart(3, '0')}.jpg`,
                        groundTruth: labelIdx
                    };
                });
            }
        }

        function renderDatasetGrid() {
            datasetGrid.innerHTML = '';
            BENCHMARK_DATA.forEach(item => {
                const div = document.createElement('div');
                div.className = 'dataset-item';
                const labelName = LABELS[item.groundTruth] ? LABELS[item.groundTruth].ja : "不明";
                const imgSrc = item.path;
                div.innerHTML = `
                    <img src="${imgSrc}" loading="lazy" onerror="this.src='https://via.placeholder.com/150?text=No+Img'">
                    <div class="dataset-label">${labelName}</div>
                `;
                div.onclick = () => openModal(imgSrc);
                datasetGrid.appendChild(div);
            });
        }

        // --- Model Loading ---
        async function loadModel(auto = false) {
            const btn = document.getElementById('load-btn');
            const modelPath = modelPathInput.value || DEFAULT_MODEL_PATH;
            currentModelName = modelPath.split('/').pop() || modelPath;

            btn.disabled = true;
            btnRunBench.disabled = true;
            btnRunCustom.disabled = true;
            setModelStatus("読み込み中...", "pending");

            try {
                if (workerReady) {
                    await loadModelOnWorker(currentModelName, modelPath);
                    modelLoadedOnWorker = true;
                    session = null;
                    useMockInference = false;
                    setModelStatus("準備完了 (Worker)", "ok");
                } else {
                    await loadModelInMain(modelPath);
                    modelLoadedOnWorker = false;
                    useMockInference = false;
                    setModelStatus("準備完了 (Main)", "ok");
                }
                updateModelDisplay(false);
            } catch (err) {
                console.warn("Worker load failed, trying main thread...", err);
                try {
                    await loadModelInMain(modelPath);
                    modelLoadedOnWorker = false;
                    useMockInference = false;
                    setModelStatus("準備完了 (Main)", "ok");
                    updateModelDisplay(false);
                } catch (e2) {
                    console.error("All load methods failed, using mock.", e2);
                    useMockInference = true;
                    setModelStatus("デモモード (Mock)", "warn");
                    updateModelDisplay(true);
                    if (!auto) alert("モデル読み込みに失敗しました。デモモードで動作します。");
                }
            } finally {
                btnRunBench.disabled = false;
                btnRunCustom.disabled = customImages.length === 0;
                btn.disabled = false;
            }
        }

        function loadModelOnWorker(name, url) {
            return new Promise((resolve, reject) => {
                const handler = (e) => {
                    const { type, name: loadedName, error } = e.data;
                    if (type === 'LOAD_DONE' && loadedName === name) {
                        worker.removeEventListener('message', handler);
                        resolve();
                    } else if (type === 'ERROR') {
                        worker.removeEventListener('message', handler);
                        reject(new Error(error));
                    }
                };
                worker.addEventListener('message', handler);
                worker.postMessage({ type: 'LOAD', data: { name, url } });
            });
        }

        async function loadModelInMain(path) {
            session = await ort.InferenceSession.create(path, {
                executionProviders: ['wasm'],
                graphOptimizationLevel: 'basic'
            });
        }

        // --- Inference Pipeline ---
        async function runBenchmark() {
            if (isRunning) return;
            if (BENCHMARK_DATA.length === 0) { alert("データがありません"); return; }

            isRunning = true;
            btnRunBench.disabled = true;
            btnRunCustom.disabled = true;

            benchTableBody.innerHTML = "";
            benchAccEl.innerText = "計測中...";
            benchTimeEl.innerText = "計測中...";
            benchProgEl.innerText = `0/${BENCHMARK_DATA.length}`;
            benchProgressContainer.style.display = 'block';
            benchProgressBar.style.width = '0%';

            let correct = 0;
            let totalTime = 0;

            for (let i = 0; i < BENCHMARK_DATA.length; i++) {
                const item = BENCHMARK_DATA[i];
                try {
                    const { imageData, src } = await loadImageData(item.path);
                    const { predIdx, conf, inferTime } = await inferWithFallback(imageData, item.groundTruth);

                    totalTime += inferTime;
                    const isCorrect = (predIdx === item.groundTruth);
                    if (isCorrect) correct++;

                    // Render Row
                    const gtLabel = LABELS[item.groundTruth]?.ja || "不明";
                    const predLabel = LABELS[predIdx]?.ja || "エラー";
                    const statusIcon = isCorrect ? '✅' : '❌';
                    const rowClass = isCorrect ? '' : 'bg-red-50';

                    const row = `
                        <tr class="${rowClass}">
                            <td class="col-res"><span class="status-icon">${statusIcon}</span></td>
                            <td><img src="${src}" class="thumb" onclick="openModal('${src}')"></td>
                            <td>
                                <div class="flex items-center gap-2">
                                    <div><span class="text-[10px] text-gray-500 block">正解</span>${gtLabel}</div>
                                    ${!isCorrect ? `<span class="text-gray-300">→</span><div><span class="text-[10px] text-red-400 block">予測</span><span class="font-bold text-red-600">${predLabel}</span></div>` : ''}
                                </div>
                            </td>
                            <td class="col-conf">${(conf * 100).toFixed(1)}%</td>
                        </tr>
                    `;
                    benchTableBody.insertAdjacentHTML('afterbegin', row);

                    // Update Stats
                    const count = i + 1;
                    benchProgEl.innerText = `${count}/${BENCHMARK_DATA.length}`;
                    benchAccEl.innerText = `${((correct / count) * 100).toFixed(1)}%`;
                    benchTimeEl.innerText = `${(totalTime / count).toFixed(0)}ms`;
                    benchProgressBar.style.width = `${Math.round((count / BENCHMARK_DATA.length) * 100)}%`;

                } catch (e) {
                    console.error(`Error processing ${item.path}`, e);
                }

                if (i % 5 === 0) await new Promise(r => requestAnimationFrame(r));
            }

            isRunning = false;
            btnRunBench.disabled = false;
            btnRunCustom.disabled = customImages.length === 0;
            setTimeout(() => { benchProgressContainer.style.display = 'none'; }, 1000);
        }

        async function runCustomBatch() {
            if (isRunning || customImages.length === 0) return;

            isRunning = true;
            btnRunBench.disabled = true;
            btnRunCustom.disabled = true;
            customResultPanel.style.display = 'block';

            const tbody = document.getElementById('custom-table-body');
            tbody.innerHTML = "";

            let correct = 0;
            let validCount = 0;
            let totalTime = 0;

            for (const item of customImages) {
                try {
                    const { imageData, src } = await loadImageData(URL.createObjectURL(item.file));
                    const { predIdx, conf, inferTime } = await inferWithFallback(imageData, item.labelIndex);

                    totalTime += inferTime;
                    if (item.labelIndex !== -1) {
                        validCount++;
                        if (predIdx === item.labelIndex) correct++;
                    }

                    const targetLabel = (item.labelIndex !== -1) ? LABELS[item.labelIndex].ja : "未指定";
                    const predLabel = LABELS[predIdx]?.ja || "エラー";
                    const isCorrect = (item.labelIndex !== -1 && predIdx === item.labelIndex);
                    const statusIcon = isCorrect ? '✅' : (item.labelIndex !== -1 ? '❌' : '－');

                    const row = `
                        <tr>
                            <td class="col-res"><span class="status-icon">${statusIcon}</span></td>
                            <td><img src="${src}" class="thumb" onclick="openModal('${src}')"></td>
                            <td>
                                <div class="flex items-center gap-2">
                                    <div><span class="text-[10px] text-gray-500 block">指定</span>${targetLabel}</div>
                                    <span class="text-gray-300">→</span>
                                    <div><span class="text-[10px] text-gray-500 block">予測</span>${predLabel}</div>
                                </div>
                            </td>
                            <td class="col-conf">${(conf * 100).toFixed(1)}%</td>
                        </tr>
                    `;
                    tbody.insertAdjacentHTML('afterbegin', row);

                    // Update Stats
                    if (validCount > 0) document.getElementById('custom-acc').innerText = `${((correct / validCount) * 100).toFixed(1)}%`;
                    document.getElementById('custom-count').innerText = customImages.length;
                    document.getElementById('custom-time').innerText = `${(totalTime / customImages.length).toFixed(0)}ms`;

                } catch (e) {
                    console.error("Custom inference error", e);
                }
            }

            isRunning = false;
            btnRunBench.disabled = false;
            btnRunCustom.disabled = false;
        }

        // --- Helper Functions ---
        async function loadImageData(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 224;
                    canvas.height = 224;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, 224, 224);
                    const imageData = ctx.getImageData(0, 0, 224, 224);
                    resolve({ imageData: imageData.data, src: img.src });
                };
                img.onerror = reject;
                img.src = url;
            });
        }

        async function inferWithFallback(pixelData, groundTruth) {
            let predIdx, conf, inferTime;

            if (useMockInference) {
                // Mock
                await new Promise(r => setTimeout(r, 50));
                predIdx = Math.floor(Math.random() * LABELS.length);
                if (Math.random() > 0.3 && groundTruth !== undefined) predIdx = groundTruth;
                conf = 0.8 + Math.random() * 0.19;
                inferTime = 50;
            } else if (modelLoadedOnWorker && workerReady) {
                // Worker
                try {
                    const res = await runInferenceOnWorker(pixelData);
                    const probs = res.probs;
                    predIdx = probs.indexOf(Math.max(...probs));
                    conf = probs[predIdx];
                    inferTime = res.time;
                } catch (e) {
                    console.error("Worker inference failed", e);
                    // Fallback to main? No, if worker loaded it, main might not have it.
                    // But if we want robust fallback, we should try main if session exists there.
                    // Here we just return error state or mock.
                    predIdx = -1; conf = 0; inferTime = 0;
                }
            } else if (session) {
                // Main Thread
                try {
                    const tensor = imageToTensor(pixelData);
                    const start = performance.now();
                    const results = await session.run({ [session.inputNames[0]]: tensor });
                    const end = performance.now();
                    const probs = softmax(Array.from(results[session.outputNames[0]].data));
                    predIdx = probs.indexOf(Math.max(...probs));
                    conf = probs[predIdx];
                    inferTime = end - start;
                } catch (e) {
                    console.error("Main thread inference failed", e);
                    predIdx = -1; conf = 0; inferTime = 0;
                }
            } else {
                // No model loaded
                predIdx = -1; conf = 0; inferTime = 0;
            }
            return { predIdx, conf, inferTime };
        }

        function runInferenceOnWorker(pixelData) {
            return new Promise((resolve, reject) => {
                const handler = (e) => {
                    const { type, result, error } = e.data;
                    if (type === 'RUN_DONE') {
                        worker.removeEventListener('message', handler);
                        resolve(result);
                    } else if (type === 'ERROR') {
                        worker.removeEventListener('message', handler);
                        reject(new Error(error));
                    }
                };
                worker.addEventListener('message', handler);
                worker.postMessage({ type: 'RUN', data: { pixelData } }, [pixelData.buffer]);
            });
        }

        function imageToTensor(data) {
            // Main thread tensor creation (duplicate of worker logic for fallback)
            const float32Data = new Float32Array(1 * 3 * 224 * 224);
            const mean = [0.485, 0.456, 0.406];
            const std = [0.229, 0.224, 0.225];
            for (let i = 0; i < 224 * 224; i++) {
                float32Data[i] = (data[i * 4] / 255.0 - mean[0]) / std[0];
                float32Data[224 * 224 + i] = (data[i * 4 + 1] / 255.0 - mean[1]) / std[1];
                float32Data[2 * 224 * 224 + i] = (data[i * 4 + 2] / 255.0 - mean[2]) / std[2];
            }
            return new ort.Tensor('float32', float32Data, [1, 3, 224, 224]);
        }

        function softmax(arr) {
            const max = Math.max(...arr);
            const exps = arr.map(x => Math.exp(x - max));
            const sum = exps.reduce((a, b) => a + b, 0);
            return exps.map(x => x / sum);
        }

        function handleCustomFiles(input) {
            // Cleanup old URLs
            customImages.forEach(item => {
                if (item.file) URL.revokeObjectURL(item.file); // Note: item.file is File object, URL is created on demand or stored?
                // Actually I was creating URL.createObjectURL(item.file) in render.
                // Better to store the URL if I want to revoke it, or just let browser handle it.
                // But user asked to "reset list".
            });

            const container = document.getElementById('custom-staging');
            container.innerHTML = "";
            customImages = [];

            if (input.files.length === 0) {
                container.innerHTML = '<p class="text-xs text-gray-400 text-center">ここにプレビューが表示されます</p>';
                btnRunCustom.disabled = true;
                return;
            }

            Array.from(input.files).forEach(file => {
                const div = document.createElement('div');
                div.className = "custom-item";
                const url = URL.createObjectURL(file);
                const img = document.createElement('img');
                img.src = url;
                img.className = "thumb";
                img.onclick = () => openModal(url);

                const select = document.createElement('select');
                let optionsHtml = `<option value="-1">正解ラベルを選択...</option>`;
                LABELS.forEach((l, i) => { optionsHtml += `<option value="${i}">[${i}] ${l.ja} (${l.en})</option>`; });
                select.innerHTML = optionsHtml;
                select.onchange = (e) => {
                    const idx = customImages.findIndex(x => x.div === div);
                    if (idx >= 0) customImages[idx].labelIndex = parseInt(e.target.value);
                };

                div.appendChild(img);
                div.appendChild(select);
                container.appendChild(div);
                customImages.push({ file, labelIndex: -1, div, url }); // Store URL to revoke later if needed
            });
            btnRunCustom.disabled = false;
        }

        function clearCustom() {
            document.getElementById('custom-staging').innerHTML = '<p class="text-xs text-gray-400 text-center">ここにプレビューが表示されます</p>';
            document.getElementById('custom-files').value = "";
            customImages.forEach(i => URL.revokeObjectURL(i.url));
            customImages = [];
            document.getElementById('custom-result-panel').style.display = 'none';
            btnRunCustom.disabled = true;
        }

        function setModelStatus(text, variant) {
            statusEl.innerText = text;
            if (variant === "ok") {
                statusEl.className = "text-xs px-2 py-1 rounded bg-green-100 text-green-800 font-bold";
            } else if (variant === "warn") {
                statusEl.className = "text-xs px-2 py-1 rounded bg-blue-100 text-blue-800 font-bold";
            } else {
                statusEl.className = "text-xs px-2 py-1 rounded bg-yellow-100 text-yellow-800 font-bold";
            }
        }

        function updateModelDisplay(isMock) {
            document.querySelectorAll('.model-name-display').forEach(el => {
                el.innerText = `Model: ${isMock ? '(Mock) ' : ''}${currentModelName}`;
            });
        }

        function openModal(src) {
            document.getElementById('modal-img').src = src;
            document.getElementById('image-modal').classList.add('active');
        }
        function closeModal() {
            document.getElementById('image-modal').classList.remove('active');
        }
        function switchTab(tabId) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tabId}')"]`).classList.add('active');
            document.getElementById('view-bench').classList.add('hidden');
            document.getElementById('view-dataset').classList.add('hidden');
            document.getElementById('view-custom').classList.add('hidden');
            document.getElementById(`view-${tabId}`).classList.remove('hidden');
        }
    </script>
</body>

</html>
```